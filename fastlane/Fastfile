# Fastlane configuration for Jenkins Dashboard
# Fetches version info from App Store Connect and Google Play

import "./dashboard_helper.rb"

# App configurations
APPS = {
  "trucks_off_road" => {
    ios_bundle_id: "au.com.oddgames.trucksoffroad",
    android_package: "au.com.oddgames.trucksoffroad"
  },
  "monster_truck_destruction" => {
    ios_bundle_id: "com.chillingo.monstertruckdestruction",
    android_package: "au.com.oddgames.monstertruckdestruction"
  }
}

# Load API key for App Store Connect
def load_asc_api_key
  api_key_path = File.expand_path("../apple_api_key.json", __FILE__)
  if File.exist?(api_key_path)
    key_data = JSON.parse(File.read(api_key_path))
    app_store_connect_api_key(
      key_id: key_data["key_id"],
      issuer_id: key_data["issuer_id"],
      key_content: key_data["key"],
      is_key_content_base64: false
    )
  else
    UI.error("Apple API key not found at #{api_key_path}")
    nil
  end
end

platform :ios do
  desc "Get version info for all iOS apps"
  lane :get_versions do
    load_asc_api_key

    results = {}

    APPS.each do |app_name, config|
      begin
        # Get app info from App Store Connect
        app = Spaceship::ConnectAPI::App.find(config[:ios_bundle_id])

        if app
          # Get all versions
          versions = app.get_app_store_versions

          live_version = versions.find { |v| v.app_store_state == "READY_FOR_SALE" }
          pending_version = versions.find { |v| ["WAITING_FOR_REVIEW", "IN_REVIEW", "PENDING_DEVELOPER_RELEASE"].include?(v.app_store_state) }

          # Get TestFlight builds
          builds = app.get_builds.first(5)
          latest_testflight = builds.first

          results[app_name] = {
            bundle_id: config[:ios_bundle_id],
            live: live_version ? {
              version: live_version.version_string,
              build: live_version.build&.version,
              state: live_version.app_store_state
            } : nil,
            pending: pending_version ? {
              version: pending_version.version_string,
              build: pending_version.build&.version,
              state: pending_version.app_store_state
            } : nil,
            testflight: latest_testflight ? {
              version: latest_testflight.version,
              build: latest_testflight.build_number,
              uploaded: latest_testflight.uploaded_date
            } : nil
          }
        else
          results[app_name] = { error: "App not found" }
        end
      rescue => e
        results[app_name] = { error: e.message }
      end
    end

    # Output as JSON for parsing
    puts "---JSON_START---"
    puts JSON.pretty_generate(results)
    puts "---JSON_END---"

    results
  end

  desc "Get version info for a specific iOS app"
  lane :get_version do |options|
    bundle_id = options[:bundle_id]
    UI.user_error!("bundle_id is required") unless bundle_id

    load_asc_api_key

    app = Spaceship::ConnectAPI::App.find(bundle_id)
    UI.user_error!("App not found: #{bundle_id}") unless app

    versions = app.get_app_store_versions
    builds = app.get_builds.first(10)

    live_version = versions.find { |v| v.app_store_state == "READY_FOR_SALE" }
    pending_version = versions.find { |v| ["WAITING_FOR_REVIEW", "IN_REVIEW", "PENDING_DEVELOPER_RELEASE"].include?(v.app_store_state) }

    result = {
      bundle_id: bundle_id,
      live: live_version ? {
        version: live_version.version_string,
        build: live_version.build&.version,
        state: live_version.app_store_state
      } : nil,
      pending: pending_version ? {
        version: pending_version.version_string,
        build: pending_version.build&.version,
        state: pending_version.app_store_state
      } : nil,
      testflight_builds: builds.map { |b|
        {
          version: b.version,
          build: b.build_number,
          uploaded: b.uploaded_date,
          processing: b.processing_state
        }
      }
    }

    puts "---JSON_START---"
    puts JSON.pretty_generate(result)
    puts "---JSON_END---"

    result
  end
end

platform :android do
  desc "Get version info for all Android apps"
  lane :get_versions do
    results = {}

    APPS.each do |app_name, config|
      begin
        # Get track versions from Google Play
        tracks_info = {}

        ["production", "beta", "alpha", "internal"].each do |track|
          begin
            version_codes = google_play_track_version_codes(
              package_name: config[:android_package],
              track: track,
              json_key: "fastlane/google_play_key.json"
            )

            if version_codes && !version_codes.empty?
              tracks_info[track] = {
                version_codes: version_codes,
                latest: version_codes.max
              }
            end
          rescue => e
            # Track might not exist or be empty
            UI.message("Track #{track} not available for #{app_name}: #{e.message}")
          end
        end

        results[app_name] = {
          package_name: config[:android_package],
          tracks: tracks_info
        }
      rescue => e
        results[app_name] = { error: e.message }
      end
    end

    puts "---JSON_START---"
    puts JSON.pretty_generate(results)
    puts "---JSON_END---"

    results
  end

  desc "Get version info for a specific Android app"
  lane :get_version do |options|
    package_name = options[:package_name]
    UI.user_error!("package_name is required") unless package_name

    tracks_info = {}

    ["production", "beta", "alpha", "internal"].each do |track|
      begin
        version_codes = google_play_track_version_codes(
          package_name: package_name,
          track: track,
          json_key: "fastlane/google_play_key.json"
        )

        if version_codes && !version_codes.empty?
          tracks_info[track] = {
            version_codes: version_codes,
            latest: version_codes.max
          }
        end
      rescue => e
        UI.message("Track #{track} not available: #{e.message}")
      end
    end

    result = {
      package_name: package_name,
      tracks: tracks_info
    }

    puts "---JSON_START---"
    puts JSON.pretty_generate(result)
    puts "---JSON_END---"

    result
  end
end

# Cross-platform lane to get all versions
desc "Get version info for all apps on all platforms"
lane :get_all_versions do
  ios_versions = nil
  android_versions = nil

  begin
    ios_versions = ios_get_versions
  rescue => e
    ios_versions = { error: e.message }
  end

  begin
    android_versions = android_get_versions
  rescue => e
    android_versions = { error: e.message }
  end

  result = {
    timestamp: Time.now.iso8601,
    ios: ios_versions,
    android: android_versions
  }

  puts "---JSON_START---"
  puts JSON.pretty_generate(result)
  puts "---JSON_END---"

  result
end
